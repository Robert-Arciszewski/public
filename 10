import os
import sys
import json
import gzip
import brotli
import subprocess
import requests
import urllib3
from typing import Dict, Any, Optional

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# -------------------- KONFIG --------------------

# 1) URL do Kibany (podmieÅ„ na swÃ³j; flaga compress moÅ¼esz zmieniÄ‡ na True/False)
KIBANA_URL = os.environ.get(
    "KIBANA_URL",
    "https://twoja-kibana.example.com/internal/bsearch?compress=true",
)

# 2) ÅšcieÅ¼ki
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.abspath(os.path.join(BASE_DIR))  # repo/kibana jeÅ›li chcesz

COOKIES_PATH = os.environ.get("COOKIES_PATH", os.path.join(BASE_DIR, "cookies.json"))
GET_COOKIE_SCRIPT = os.environ.get(
    "GET_COOKIE_SCRIPT", os.path.join(BASE_DIR, "kibana_get_cookie.py")
)

# 3) Nazwy plikÃ³w wej/wyj wewnÄ…trz logs/<test_number>/
PAYLOAD_FILENAME = os.environ.get("PAYLOAD_FILENAME", "payload.json")
OUTPUT_JSON_FILENAME = "response.json"
OUTPUT_RAW_FILENAME = "response_raw.txt"

# 4) Wymagane klucze z cookies.json
COOKIE_KEYS_REQUIRED = ["AUTH0_SESSION_ID", "access_token"]

# 5) NagÅ‚Ã³wki â€“ wystarczajÄ…co â€przeglÄ…darkoweâ€, ale bez zbÄ™dnych Å›mieci
DEFAULT_HEADERS = {
    "accept": "*/*",
    "accept-language": "pl,en;q=0.9",
    "content-type": "application/json",
    "kbn-xsrf": "true",
    "origin": "https://twoja-kibana.example.com",
    "referer": "https://twoja-kibana.example.com/app/discover",
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36",
}

# -------------------- POMOCNICZE --------------------


def die(msg: str, code: int = 1) -> None:
    print(f"âŒ {msg}")
    sys.exit(code)


def load_json(path: str) -> Any:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def dump_pretty_json(path: str, obj: Any) -> None:
    with open(path, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)


def ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)


def load_cookies() -> Optional[Dict[str, str]]:
    """Åaduje cookies z COOKIES_PATH i zwraca dict pod requests.cookies"""
    try:
        cookies_list = load_json(COOKIES_PATH)
    except Exception as e:
        print(f"âš ï¸  Nie udaÅ‚o siÄ™ wczytaÄ‡ {COOKIES_PATH}: {e}")
        return None

    # ObsÅ‚uÅ¼ dwa typy formatÃ³w: lista obiektÃ³w z 'name'/'value' albo zwykÅ‚y dict
    cookies: Dict[str, str] = {}
    if isinstance(cookies_list, list):
        for c in cookies_list:
            name = c.get("name")
            value = c.get("value")
            if name and value:
                cookies[name] = value
    elif isinstance(cookies_list, dict):
        cookies = {k: str(v) for k, v in cookies_list.items()}

    return cookies or None


def have_required_cookies(cookies: Dict[str, str]) -> bool:
    return all(k in cookies and cookies[k] for k in COOKIE_KEYS_REQUIRED)


def maybe_get_cookies_via_helper() -> Dict[str, str]:
    """
    JeÅ›li cookies brakuje â€“ uruchom skrypt pomocniczy.
    Po jego zakoÅ„czeniu sprÃ³buj ponownie wczytaÄ‡ cookies.
    """
    print("â„¹ï¸  Brakuje wymaganych ciastek â€“ odpalam pomocniczy skrypt, aby je pobraÄ‡â€¦")
    try:
        subprocess.run([sys.executable, GET_COOKIE_SCRIPT], check=True)
    except FileNotFoundError:
        die(f"Brak skryptu pomocniczego: {GET_COOKIE_SCRIPT}")
    except subprocess.CalledProcessError as e:
        die(f"Skrypt pomocniczy zakoÅ„czyÅ‚ siÄ™ bÅ‚Ä™dem: {e}")

    cookies = load_cookies()
    if not cookies or not have_required_cookies(cookies):
        die("Nadal brakuje wymaganych ciastek po uruchomieniu skryptu pomocniczego.")
    print("âœ… UÅ¼ywam Å›wieÅ¼o pobranych ciastek.")
    return cookies


def decode_maybe_compressed(content: bytes, enc_header: str) -> bytes:
    """
    Zwraca zdekodowane bajty, jeÅ›li serwer skompresowaÅ‚ odpowiedÅº.
    ObsÅ‚uguje gzip i br (brotli). W przeciwnym razie zwraca content bez zmian.
    """
    if not content:
        return content
    enc_header = (enc_header or "").lower()
    try:
        if "gzip" in enc_header:
            return gzip.decompress(content)
        if "br" in enc_header or "brotli" in enc_header:
            return brotli.decompress(content)
    except Exception:
        # jak siÄ™ nie uda â€“ trudno, oddaj surowe
        pass
    return content


# -------------------- GÅÃ“WNY PRZEPÅYW --------------------


def main() -> None:
    # Numer testu z argv
    if len(sys.argv) <= 1:
        die("Nie podano numeru testu. UÅ¼ycie: python kibana_bsearch.py <test_number>")

    test_number = str(sys.argv[1]).strip()
    logs_dir = os.path.join(PROJECT_ROOT, "logs", test_number)
    ensure_dir(logs_dir)

    payload_path = os.path.join(logs_dir, PAYLOAD_FILENAME)
    output_json_path = os.path.join(logs_dir, OUTPUT_JSON_FILENAME)
    output_raw_path = os.path.join(logs_dir, OUTPUT_RAW_FILENAME)

    print(f"ğŸ—‚  PROJECT_ROOT: {PROJECT_ROOT}")
    print(f"ğŸ“ PAYLOAD_PATH: {payload_path}")
    print(f"ğŸ“¤ RESPONSE_JSON: {output_json_path}")
    print(f"ğŸ“„ RESPONSE_RAW:  {output_raw_path}")

    # 1) Cookies
    cookies = load_cookies()
    if not cookies or not have_required_cookies(cookies):
        cookies = maybe_get_cookies_via_helper()

    # 2) Payload
    try:
        data = load_json(payload_path)
    except Exception as e:
        die(f"Nie udaÅ‚o siÄ™ wczytaÄ‡ payloadu z {payload_path}: {e}")

    # 3) Request
    print(f"ğŸŒ POST {KIBANA_URL}")
    try:
        resp = requests.post(
            KIBANA_URL,
            headers=DEFAULT_HEADERS,
            cookies=cookies,
            json=data,
            timeout=60,
            verify=False,  # kibana bywa na self-signed; jeÅ›li masz cert, ustaw True
        )
    except Exception as e:
        die(f"BÅ‚Ä…d podczas wywoÅ‚ania requestu: {e}")

    print(f"Status: {resp.status_code}")

    # 4) SprÃ³buj Å‚adnie jako JSON
    try:
        parsed = resp.json()
        # krÃ³tki podglÄ…d
        preview = json.dumps(parsed, ensure_ascii=False)[:1000]
        print("ğŸ“¦ OdpowiedÅº JSON (pierwsze 1000 znakÃ³w):")
        print(preview)
        dump_pretty_json(output_json_path, parsed)
        print(f"âœ… Zapisano odpowiedÅº jako {output_json_path}")
        sys.exit(0)
    except json.JSONDecodeError:
        print("âš ï¸  Nie wyglÄ…da na JSON. PrÃ³bujÄ™ zdekompresowaÄ‡ i zapisaÄ‡ surowÄ… odpowiedÅºâ€¦")
    except Exception as e:
        print(f"âš ï¸  Nie udaÅ‚o siÄ™ sparsowaÄ‡ odpowiedzi jako JSON: {e}")

    # 5) Surowa odpowiedÅº (z ewentualnÄ… dekompresjÄ…)
    try:
        enc = resp.headers.get("Content-Encoding", "")
        decoded = decode_maybe_compressed(resp.content, enc)
        with open(output_raw_path, "wb") as f:
            f.write(decoded if decoded is not None else resp.content)
        print(f"ğŸ“ Zapisano surowÄ… odpowiedÅº do {output_raw_path}")
    except Exception as e:
        print(f"âš ï¸  Nie udaÅ‚o siÄ™ zapisaÄ‡ surowej odpowiedzi: {e}")

    # zgodnie z TwojÄ… notkÄ…: nie ponawiamy logowania; koÅ„czymy bez bÅ‚Ä™du
    print("â›” Nie uruchamiam ponownie logowania.")
    sys.exit(0)


if __name__ == "__main__":
    main()
q
